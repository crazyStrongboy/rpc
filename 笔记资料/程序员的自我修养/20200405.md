### 编译与链接

#### 预编译

该过程主要是为了处理源代码中含有“#”号的预编译指令。包括删除所有的注释，以及给每一行添加行号等等。



#### 编译

##### 词法分析

将源码输入到**扫描器（Scanner）**，进行简单的词法分析，运用一种类似于**有限状态机（Finite State Machine）**的算法轻松地将源代码的字符序列分割成一系列的**记号（token）**。例如可以利用一个叫做lex的程序实现词法扫描。

##### 语法分析

**语法分析器（Grammer Parser）**将对扫描器产生的token进行分析，进而产生**语法树（Syntax Tree）**。简单的讲，由语法分析器生成的语法树就是以表达式为节点的树。如果表达式不合法，比如括号不匹配、表达式中缺少操作符等等，编译器就会报告语法分析阶段的错误。例如可以利用一个现成的工具yacc。

##### 语义分析

**语义分析器（Semantic Analyzer）**只能分析编译期可以确定的语义，即**静态语义（Static Semantic）**，包括声明和类型的匹配，类型的转换。比如当一个浮点型转换为整形时，其中就包含了一个隐式转换的过程，语义分析过程中需要完成这样一个步骤。比如当将一个浮点类型赋值给一个指针时，语义分析程序会发现这个类型不匹配，编译器就会报错。

**动态语义（Dynamic Semantic）**就是只有在运行时期才能确定的语义，比如将0作为除数是一个运行时期的语义错误。

##### 中间语言生成

**源码优化器（Source Code Optimizer）**在不同编译器中可能会有不同的定义或有一些差异。其会在源码级别进行优化。例如`var a int = 2+4`，这个表达式可能被优化成`var a int = 6`，因为它的值在编译期就可以确定了。但是直接在语法树上做优化比较困难，所以源代码优化器往往将整个语法树转换成**中间代码（Intermediate Code）**，比较常见的有**三地址码（Three-address Code）**和**P-代码（P-Code）**。

基本的三地址码是这样的`x=y op z`，例如：

```go
array[i] = i * (4 + 2)
===>
t1 = 4 + 2
t2 = i * t1
array[i] =  t2
===>进一步优化成
t1 = i * 6
array[i] = t1
```

所以编译器可以分为前端和后端。前端负责生产和机器无关的中间代码，后端将中间代码转换为目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

##### 生成目标代码及优化

编译器后端主要包括**代码生成器（Code Generator）**和**目标代码优化器（Target Code Optimizer）**。代码生成器将中间代码转换为目标机器代码，这个过程依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数据类型等。



#### 汇编

**汇编器**将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。



#### 链接

在经过编译器将一个个源代码文件编译成一个未链接的目标文件，最终需要由连接器将这些目标文件链接起来形成可执行文件，这个组装的过程就是**链接（Linking）**。链接的出现解决了不需要将所有的源代码写到同一个文件当中，将其拆分为多个模块，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序。

链接的主要过程包括地址和空间的分配、符号决议、重定位等步骤。例如：在目标文件B中有一个变量var，在编译这个源文件时，编译器在没办法确定地址的情况下，会将其地址设为0，等待目标文件A和B链接起来时再将其修正。这个地址的修正过程也被叫做**重定位（Relocation）**，每一个要被修正从地方叫一个**重定位入口（Relocation Entry）**。在源文件B进行修改后，其变量var的地址有可能被改变，所以所有用到变量var的地址的指令在进行链接时都要全部重新调整。

