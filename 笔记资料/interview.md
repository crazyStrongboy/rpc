

#### http和https

1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

##### https的流程

1. 在浏览器中输入一个https地址，连接服务器的443端口。
2. 服务端会返回对应证书的公钥，并且会额外返回颁发机构，过期时间等等信息。
3. 客户端解析证书，验证证书是否有效。
4. 传送加密信息，这里传送的是用证书加密后的随机值，目的就是让服务端得到这个值，后面服务端和客户端通信就是用这个值来加密数据的。
5. 服务端解密信息，得到客户端传来的随机值，然后把内容通过该值进行对称加密。
6. 把加密后的信息返回给客户端
7. 客户端通过之前的随机值进行解密。

#### mongo和redis对比

#### consul与zookeeper对比

#### 网络安全

#### 加密协议



#### 用户量很大，但是很多都是僵尸用户，常用保活就行，要针对高频用户分配多个goroutine该怎么去处理？



#### cgo和普通函数的区别？

调用`runtime.asmcgocall`时会切换到go栈，（Go使用的是分段栈，在不够用时会进行动态增长。然而C函数不使用分段栈技术，并且假设栈是足够大的，因此调用cgo时使用的是m的g0栈，g0栈是固定的8K大小，`mp->g0 = runtime·malg(8192)`，这样相对来说会比较安全），在调用返回时，将会切换栈到`m.currg`的栈并且返回给`runtime.cgocall`。

##### 进入系统调用

Go的运行时库对系统调用作了特殊处理，所有涉及到调用系统调用之前，都会先调用runtime.entersyscall，而在出系统调用函数之后，会调用runtime.exitsyscall。这样做原因跟调度器相关，目的是始终维持GOMAXPROCS的数量，当进入到系统调用时，runtime.entersyscall会将P的M剥离并将它设置为PSyscall状态，告知系统此时其它的P有机会运行，以保证始终是GOMAXPROCS个P在运行。

runtime.entersyscall函数会立刻返回，它仅仅是起到一个通知的作用。那么这跟cgo又有什么关系呢？这个关系可大着呢！在执行cgo函数调用之前，其实系统会先调用runtime.entersyscall。这是一个很关键的处理，Go把cgo的C函数调用像系统调用一样独立出去了，不让它影响运行时库。这就回答了前面提出的第二个问题：Go中的goroutine都是协作式的，运行到调用runtime库时就有机会进行调度。然而C函数是不会与Go的runtime做这种交互的，所以cgo的函数不是一个协作式的，那么如何避免进入C函数的这个goroutine“失控”？答案就在这里。将C函数像处理系统调用一样隔离开来，这个goroutine也就不必参与调度了。而其它部分的goroutine正常的运行不受影响。

##### 退出系统调用

退出系统调用跟进入系统调用是一个相反的过程，runtime.exitsyscall函数会查看当前仍然有可用的P，则让它继续运行，否则这个goroutine就要被挂起了。

对于cgo的代码也是同样的作用，出了cgo的C函数调用之后会调用runtime.exitsyscall。



#### Redis的持久化AOF的优势

1. 能够给数据带来更高的安全性，数据的同步操作都是异步完成的。
2. 对日志的写入是采用的append模式，因此在写入过程中出现宕机问题，也不会影响前面的数据。如果写到一半出问题了，在redis重启时会通过工具redis-check-aof去解决数据一致性问题。
3. AOF文件越来越大，定期对AOF文件进行重写，达到压缩的目的。更小的AOF文件能够被Redis更快的加载。

- 超时的数据不再写入文件
- 进行命令的合并





#### mongodb分片

