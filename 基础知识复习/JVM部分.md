#### 双亲委派机制
![类加载器模型](https://i.imgur.com/TyKzmuI.png)


- 双亲委派模型中除了启动类加载器，其他类加载器都有属于自己的父类。
- 当一个类加载器收到加载请求时，它不会自己马上加载，而是会委派给自己的父类。逐级向上委派进行加载。

双亲委派的好处：由于每个类都会经过最顶层的启动类加载器，这样可以保证每一个相同的类只会被同一个加载器加载，这样两个类才会相等。如果没有双亲委派模型，当用户自己编写一个`java.lang.Object`这样的类，那么系统中会出现多个`Object`,这样会导致JAVA程序变得异常混乱。

#### 垃圾回收
##### 对象是否存活

- 引用计数法：每当一个地方进行引用，则引用计数器+1，失效时则-1。算法简单高效，但是无法解决循环引用的问题。
- 可达性分析算法：通过一个GC Roots的对象向下检索，整个搜索路径被称之为引用链，当一个对象到GC Roots没有任何引用链时，JVM就认定该对象是可以被回收的。

	>可以作为GC Roots的对象有:
	>
	>方法区中静态变量所引用的对象。
	>
	>虚拟机栈中所引用的对象。

##### 清除算法
- 标记清除算法：先标记所有要清除的对象，然后统一清除。效率极低，清除后容易出现不连续性的内存，当分配一个较大的内存空间时，就不得不进行再一次的垃圾回收。
- 复制算法：适用于对象存活率较低的环境当中，简单高效，但是容易浪费内存。
 >新生代中分为一个Eden区和两个Survior区，通常两个区的比例是8:1:1。这个也可以根据自己的需要去做调整。使用时会用到Eden区和其中一个Survior区。当发生垃圾回收时，会将Eden区和Survior区中的数据拷贝到另一个Survior区中，当该区域内存不足时会使用分配担保机制利用老年代来存放数据。（Eden和from survior区域中的内存会在垃圾回收的过程中全部释放）


- 标记整理算法：和标记清除算法类似，但是会整理内存碎片。
- 分代回收算法：新生代采用复制算法，因为新生代对象朝生夕死，存活对象比较少。老年代采用标记整理或者标记清除算法。


#### JDK 1.8 与 1.7 内存的划分
![](https://i.imgur.com/fPg3M5y.png)

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小。

